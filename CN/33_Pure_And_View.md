# Vyper 函数装饰器：Pure vs View 详解

在 Vyper 中，像 `@pure` 和 `@view` 这样的函数装饰器提供了有关函数行为的重要信息，特别是关于它与区块链状态的交互。这两个装饰器都表示函数是**只读**的，意味着它承诺不更改任何永久存储在区块链上的数据。理解它们之间的区别对于编写高效且安全的智能合约至关重要。

## 核心概念回顾

*   **只读函数 (Read-Only Functions)**：不修改区块链状态的函数（不更改状态变量）。
*   **状态变量 (State Variables)**：在合约内声明的变量，其值在区块链上持久存在（例如 `my_var: public(uint256)`）。
*   **全局变量 (Global Variables)**：EVM 提供的特殊变量（例如 `block.timestamp`, `msg.sender`）。

## @pure 装饰器

标记为 `@pure` 的函数是限制性最强的只读函数类型。

*   **限制**：Pure 函数**不能**读取合约状态变量，也**不能**读取任何全局变量（如 `block.timestamp`）。
*   **操作**：它只能操作直接传递给它的输入参数及其范围内定义的任何局部变量。
*   **类比**：这就好比一个纯数学函数。给定相同的输入，无论任何外部状态如何，它总是产生相同的输出。

### 示例：一个 @pure 函数

```vyper
@external
@pure
def add(x: uint256, y: uint256) -> uint256:
    return x + y
```

此函数主要仅依赖于 `x` 和 `y`。

## @view 装饰器

标记为 `@view` 的函数也是只读的，但它们的限制比 pure 函数少。

*   **权限**：View 函数**可以**读取合约状态变量和全局变量。
*   **限制**：至关重要的是，它仍然**不能修改**任何状态变量。它只“查看”状态。
*   **类比**：这就好比“查看”或检查合约的当前状况而不做任何更改。

### 示例：一个 @view 函数

```vyper
count: public(uint256)

@external
@view
def add_to_count(x: uint256) -> uint256:
    return x + self.count + block.timestamp
```

此函数读取 `self.count` 和 `block.timestamp`，所以它不能是 `@pure`，但因为它不修改状态，所以它是 `@view`。

## 说明界限

1.  **状态修改**：如果函数更改了状态变量（`self.count += 1`），它**不是**只读的。它不能是 `@pure` 或 `@view`。
2.  **读取状态**：如果函数返回 `x + self.count`，它读取了状态。它必须是 `@view`（或不标记），而不是 `@pure`。
3.  **读取全局变量**：如果函数返回 `x + block.timestamp`，它读取了全局变量。它必须是 `@view`（或不标记），而不是 `@pure`。

## 总结：何时使用哪个

*   **使用 `@pure`**：当你的函数**仅**基于其参数和局部变量执行计算时。不使用状态或全局变量。
*   **使用 `@view`**：当你的函数需要**读取**状态变量或全局变量但保证**不更改**任何状态时。
*   **都不使用**：如果你的函数需要**修改**合约的状态变量（例如更新余额）。
