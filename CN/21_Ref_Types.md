# 超越单个变量：介绍 Vyper 引用类型

在我们之前的 Vyper 探索中，我们经常处理简单的状态变量，比如使用 `uint256` 存储一个喜爱的数字。虽然有用，但当我们需要管理更复杂的数据或与多个用户或实体相关的数据集合时，这种方法很快就会受到限制。

```vyper
uint256
```

想象一下，试图为每个与你的合约交互的用户存储一个喜爱的数字。你可以尝试添加像 `alice_favorite_number`、`bob_favorite_number` 等单独的状态变量。然而，这是极其低效且静态的。当新用户到来时会发生什么？你需要修改合约代码，重新编译并重新部署——对于动态应用程序来说，这是一个完全不切实际的解决方案。

为了构建更智能、更灵活的合约，Vyper 提供了强大的**引用类型 (Reference Types)**。这些是设计用于高效处理集合和复杂数据分组的数据结构。与简单的**值类型 (Value Types)**（`uint256`, `bool`, `address` 等）不同——值类型的赋值或函数传递通常会创建数据的副本——引用类型通常使用指向内存或存储中数据位置的指针或引用。

本课重点介绍三种基本的 Vyper 引用类型：**固定大小列表 (Fixed-Sized Lists)**、**映射 (Mappings)** 和 **结构体 (Structs)**。我们将探讨如何声明、初始化以及与它们交互，为更复杂的合约逻辑铺平道路。

## 处理有序数据：固定大小列表

Vyper 中的固定大小列表类似于其他编程语言中的数组。它保存相同数据类型的元素序列。关键特征是其大小（它可以容纳的元素数量）在编译时是固定的，并且在合约部署后无法更改。

### 声明

要将固定大小列表声明为状态变量，你需要指定元素类型，后跟方括号 `[]` 中的固定大小。使用 `public()` 可见性修饰符会自动创建一个 Getter 函数，允许外部用户或合约从列表中读取元素。

```vyper
nums: public(uint256[10])
```

在这里，`nums` 是我们要声明的状态变量的名称。它被声明为一个公共列表，能够准确存储 10 个元素，每个元素的类型为 `uint256`。

### 初始化和访问

通常在函数内部初始化或修改列表元素，常常在合约的构造函数 (`__init__`) 中进行初始设置。访问和修改使用**从零开始的索引**，即第一个元素在索引 0，第二个在索引 1，依此类推。记得使用 `self.` 来引用合约函数内的状态变量。

```vyper
@deploy
def __init__():
    self.nums[0] = 123
    self.nums[1] = 456
```

### 默认值

固定大小列表中任何未显式赋值的元素都将自动获得其数据类型的默认值。对于 `uint256`，默认值是 0。因此，在上面的例子中，访问 `self.nums[2]`（或 2 到 9 之间的任何索引）将返回 0。

## 键值存储：映射 (Mappings / HashMaps)

映射，使用 `HashMap` 关键字声明，提供了一种存储键值对的强大方式。把它们想象成其他语言中的字典或哈希映射。你将一种数据类型的唯一**键 (Key)** 与另一种数据类型的**值 (Value)** 关联起来。

与列表不同，映射没有长度或顺序的概念，你不能在 Vyper 中直接遍历它们的键或值。当你已知其对应的键时，它们对于检索值进行了高度优化。

### 声明

声明映射涉及在 `HashMap` 结构中指定键类型和值类型。

```vyper
myMap: public(HashMap[address, uint256])
```

这声明了一个公共状态变量 `myMap`。它将 `address` 类型的键映射到 `uint256` 类型的值。这非常适合像跟踪余额、角色或与特定用户地址关联的首选项这样的场景。

### 初始化和访问

你使用方括号 `[]` 中的键来访问和修改映射中的值。

```vyper
self.myMap[msg.sender] = 100
```

如果你多次为同一个键赋值，只有最近的赋值会保留。访问尚未赋值的键将返回该值类型的默认值（例如，`uint256` 为 0）。

## 定义自定义数据结构：结构体 (Structs)

结构体允许你通过将多个变量（称为字段或成员）组合在一个名称下来创建自己的自定义、复杂数据类型。这些字段可以是不同的数据类型，包括值类型、其他结构体，甚至是固定大小列表和映射（尽管在结构体中的使用有特定考量）。

### 定义

首先，使用 `struct` 关键字定义自定义类型的结构。

```vyper
struct Person:
    name: String[10]
    age: uint256
```

这段代码定义了一个名为 `Person` 的蓝图。任何 `Person` 类型的变量都将包含两个字段：`name`（最大长度为 10 个字符的字符串）和 `age`（无符号整数）。

### 声明

定义后，你可以使用自定义结构体类型声明状态变量。

```vyper
person: public(Person)
```

这创建了一个类型为 `Person` 的名为 `person` 的状态变量。

### 访问和修改存储中的结构体字段

你使用点符号 (`.`) 访问结构体状态变量中的字段。

```vyper
self.person.name = "Alice"
self.person.age = 30
```

这些赋值直接修改存储在 `person` 状态变量区块链上的数据。

## 理解结构体的存储 (Storage) 与内存 (Memory)

处理引用类型，尤其是结构体时，一个至关重要的概念是存储 (Storage) 和内存 (Memory) 之间的区别。

*   **Storage (存储)**：这是合约的持久状态，永久存储在区块链上。状态变量（`self.nums`, `self.myMap`, `self.person`）驻留在存储中。修改存储在 Gas 成本方面相对昂贵。
*   **Memory (内存)**：这是函数执行期间使用的临时、易失性数据空间。它的使用成本比存储低，但在函数调用结束后会被清除。函数内的局部变量通常驻留在内存中。

考虑 `__init__` 函数中的以下代码，延续之前的结构体示例：

```vyper
@deploy
def __init__():
    self.person.name = "Bob"
    p: Person = self.person # p 是 MEMORY 中的副本
    p.name = "Charlie" # 仅修改内存副本！
    # self.person.name 仍然是 "Bob"
```

**关键要点**：当你将存储结构体（如 `self.person`）赋值给局部内存变量（如 `p: Person`）时，你通常是在内存中创建该数据的**副本**。对此内存副本的修改（`p.name`, `p.age`）**不会**自动反映回原始存储变量（`self.person`）。如果你打算更新持久状态，必须显式地将值赋回存储变量的字段（例如，`self.person.name = p.name`）。

理解这种区别对于编写正确且高效的 Vyper 代码至关重要，确保数据修改对合约的持久状态产生预期的效果。

固定大小列表、映射和结构体为在 Vyper 智能合约中组织复杂数据提供了构建块，超越了简单值类型的局限性，并实现了更具动态和强大的去中心化应用程序。
