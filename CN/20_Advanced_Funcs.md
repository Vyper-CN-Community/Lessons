# 探索高级 Vyper 函数语法

欢迎！在本课中，我们将超越基础，深入探讨在 Vyper 中定义函数的一些更高级的方面。虽然有些概念最初看起来可能具有挑战性，但请记住，理解来自实践和重复。我们将在一个示例合约中使用实际例子来探索特定的语法元素。此处演示的所有函数都将标记为 `@external`，这意味着一旦部署，就可以从合约外部调用它们。

## 理解函数装饰器

装饰器是以 `@` 为前缀的特殊关键字，用于修改函数的行为或属性。我们在这里关注两个关键装饰器：

*   **@external**：这可能是你最常遇到的装饰器。它将函数标记为合约公共应用程序二进制接口 (ABI) 的一部分。这意味着该函数可以通过发送到合约的交易调用，或者通过其他合约或外部账户的调用来调用。本课中的所有示例都使用 `@external`。
*   **@pure**：此装饰器表示函数承诺**不**从合约的状态存储中读取或修改。标记为 `@pure` 的函数（以及 `@view` 函数）通常可以在链下调用而不会产生 Gas 成本，前提是调用本身不会触发改变状态的交易。

## 在 Vyper 中定义函数

提醒一下，在 Vyper 中定义函数使用标准的 Python `def` 关键字，后跟函数名、参数和返回类型注解。

通用语法如下所示：
*   **parameter_name: parameter_type**：定义输入参数及其相应的数据类型（例如 `x: uint256`）。
*   **-> return_type**：指定函数将返回的值的数据类型（例如 `-> uint256`）。

## 处理整数除法

Vyper 中的一个关键点涉及整数除法。当两个整数相除且结果可能不是整数时，Vyper 需要一个特定的运算符：
*   **//**：这是**地板除 (floor division)** 运算符。它执行除法并将结果**向下**舍入到最接近的整数。

```vyper
# 正确的整数除法
result: uint256 = 5 // 2  # 结果是 2
```

使用单斜杠 `/` 不是在 Vyper 中执行整数除法的标准方式。在除整数时始终使用 `//` 以确保可预测的、向下取整的结果。

## 使用 'pass' 关键字

有时，你可能想定义一个函数的签名（其名称、参数和返回类型），但还没准备好实现其逻辑。在 Python 和 Vyper 中，你可以使用 `pass` 关键字作为占位符。

*   **pass**：这是一个空操作——执行时什么也不会发生。它充当函数体的有效占位符，即使函数什么也不做，也允许合约成功编译。

```vyper
@external
def todo():
    pass
```

## 返回多个值

Vyper 函数不仅限于只返回单个值。你可以返回多个值，可能具有不同的类型。

*   **声明多个返回类型**：在函数签名中，将多个返回类型括在括号内：`-> (type1, type2, ...)`。
*   **返回多个值**：在 return 语句中，以元组形式提供值，括在括号内：`return (value1, value2, ...)`。

## 实际示例：Func.vy 合约

让我们用一个简单的合约 `Func.vy` 来阐明这些概念。

```vyper
# Func.vy
# version 0.4.0

@external
@pure
def multiply(x: uint256, y: uint256) -> uint256:
    return x * y

@external
@pure
def divide(x: uint256, y: uint256) -> uint256:
    return x // y 

@external
def todo():
    pass

@external
@pure
def return_many() -> (uint256, bool):
    return (123, True)
```

**解释：**
1.  **multiply**：一个简单的函数，演示了 `@external`、`@pure`、参数/返回类型定义 (`uint256`) 以及标准乘法运算符 (`*`)。
2.  **divide**：此函数突出了在 Vyper 中进行整数除法时使用地板除运算符 `//` 的关键性。
3.  **todo**：展示了如何使用 `pass` 创建一个有效的空函数体。
4.  **return_many**：演示了返回多个值的语法。签名声明了 `-> (uint256, bool)`，函数返回一个元组 `(123, True)`。

## 演示函数行为

在像 Remix IDE（带有 Vyper 插件）这样的环境中编写此代码后：
1.  **编译**：`Func.vy` 合约编译成功。
2.  **部署**：合约被部署（例如，到 Remix VM）。
3.  **交互**：我们现在可以调用已部署的函数：

*   调用 `todo()` 成功执行但不执行任何操作，正如 `pass` 所预期的那样。
*   调用 `return_many()` 返回值：`uint256: 123` 和 `bool: true`。
*   调用 `multiply(x=2, y=3)` 返回 `uint256: 6`。
*   调用 `divide(x=4, y=2)` 返回 `uint256: 2`。
*   调用 `divide(x=1, y=2)` 返回 `uint256: 0`（因为 1 / 2 = 0.5，向下取整为 0）。
*   调用 `divide(x=3, y=2)` 返回 `uint256: 1`（因为 3 / 2 = 1.5，向下取整为 1）。这清楚地展示了 `//` 的地板除行为。

## 关键要点

*   打算从合约外部调用的函数必须标记为 `@external`。
*   `@pure` 函数承诺不读取或写入合约存储。
*   在 Vyper 中使用地板除运算符 `//` 进行整数除法。
*   `pass` 关键字用作空函数体的占位符。
*   在签名中使用括号指定多个返回类型：`-> (type1, type2)`。
*   以元组形式返回多个值：`return (value1, value2)`。

本课涵盖了用于在 Vyper 中定义更复杂函数的几个重要语法元素。掌握这些将允许你构建更复杂的智能合约。
